{"version":3,"sources":["webpack:///assets/js/4.7b697185a7780d1974f4.js","webpack:///./src/plugins/utils/path-to-regexp.js"],"names":["webpackJsonp","342","module","exports","parse","str","res","tokens","key","index","path","PATH_REGEXP","exec","m","escaped","offset","slice","length","next","prefix","name","capture","group","modifier","asterisk","push","partial","repeat","optional","delimiter","pattern","replace","escapeString","substr","regexpToRegexp","keys","groups","source","match","i","stringToRegexp","tokensToRegExp","route","token","RegExp","pathToRegexp","join"],"mappings":";;;;AAAAA,cAAc,IAERC,IACA,SAAUC,EAAQC,GC0BxB,QAASC,GAAMC,GAQX,IAPA,GAKIC,GALAC,KACAC,EAAM,EACNC,EAAQ,EACRC,EAAO,GAI6B,OAAhCJ,EAAMK,EAAYC,KAAKP,KAAe,CAC1C,GAAIQ,GAAIP,EAAI,GACRQ,EAAUR,EAAI,GACdS,EAAST,EAAIG,KAKjB,IAJAC,GAAQL,EAAIW,MAAMP,EAAOM,GACzBN,EAAQM,EAASF,EAAEI,OAGfH,EACAJ,GAAQI,EAAQ,OADpB,CAKA,GAAII,GAAOb,EAAII,GACXU,EAASb,EAAI,GACbc,EAAOd,EAAI,GACXe,EAAUf,EAAI,GACdgB,EAAQhB,EAAI,GACZiB,EAAWjB,EAAI,GACfkB,EAAWlB,EAAI,EAGfI,KACAH,EAAOkB,KAAKf,GACZA,EAAO,GAGX,IAAIgB,GAAoB,MAAVP,GAA0B,MAARD,GAAgBA,IAASC,EACrDQ,EAAsB,MAAbJ,GAAiC,MAAbA,EAC7BK,EAAwB,MAAbL,GAAiC,MAAbA,EAC/BM,EAAYvB,EAAI,IAjCD,IAkCfwB,EAAUT,GAAWC,CAEzBf,GAAOkB,MACHL,KAAMA,GAAQZ,IACdW,OAAQA,GAAU,GAClBU,UAAWA,EACXD,SAAUA,EACVD,OAAQA,EACRD,QAASA,EACTF,WAAYA,EACZM,QAASA,EAAUA,EAAQC,QAAQ,gBAAiB,QAAWP,EAAW,KAAO,KAAOQ,EAAaH,GAAa,SAc1H,MATIpB,GAAQJ,EAAIY,SACZP,GAAQL,EAAI4B,OAAOxB,IAInBC,GACAH,EAAOkB,KAAKf,GAGTH,EASX,QAASyB,GAAa3B,GAClB,MAAOA,GAAI0B,QAAQ,6BAA8B,QAUrD,QAASG,GAAexB,EAAMyB,GAE1B,GAAIC,GAAS1B,EAAK2B,OAAOC,MAAM,YAE/B,IAAIF,EACA,IAAK,GAAIG,GAAI,EAAGA,EAAIH,EAAOnB,OAAQsB,IAC/BJ,EAAKV,MACDL,KAAMmB,EACNpB,OAAQ,KACRU,UAAW,KACXD,UAAU,EACVD,QAAQ,EACRD,SAAS,EACTF,UAAU,EACVM,QAAS,MAKrB,OAAOpB,GAWX,QAAS8B,GAAe9B,EAAMyB,GAC1B,MAAOM,GAAerC,EAAMM,GAAOyB,GAUvC,QAASM,GAAelC,EAAQ4B,GAI5B,IAAK,GAHDO,GAAQ,GAGHH,EAAI,EAAGA,EAAIhC,EAAOU,OAAQsB,IAAK,CACpC,GAAII,GAAQpC,EAAOgC,EAEnB,IAAqB,gBAAVI,GACPD,GAASV,EAAaW,OACnB,CACH,GAAIxB,GAASa,EAAaW,EAAMxB,QAC5BE,EAAU,MAAQsB,EAAMb,QAAU,GAEtCK,GAAKV,KAAKkB,GAENA,EAAMhB,SACNN,GAAW,MAAQF,EAASE,EAAU,MAOlCA,EAJJsB,EAAMf,SACDe,EAAMjB,QAGGP,EAAS,IAAME,EAAU,KAFzB,MAAQF,EAAS,IAAME,EAAU,MAKrCF,EAAS,IAAME,EAAU,IAGvCqB,GAASrB,GAIjB,GAAIQ,GAAYG,EAAa,IAS7B,OAFAU,IANwBA,EAAM1B,OAAOa,EAAUZ,UAAYY,EAM9Ba,EAAM1B,MAAM,GAAIa,EAAUZ,QAAUyB,GAAS,MAAQb,EAAY,WAEvF,GAAIe,QAAO,IAAMF,EAAO,KAcnC,QAASG,GAAanC,EAAMyB,GACxB,MAAIzB,aAAgBkC,QACTV,EAAexB,EAA6ByB,GAGhDK,EAAuC9B,EAA8ByB,GAnNhFjC,EAAOC,QAAU0C,CAOjB,IAAIlC,GAAc,GAAIiC,SAGlB,UAOA,0GACFE,KAAK,KAAM","file":"assets/js/4.7b697185a7780d1974f4.js","sourcesContent":["webpackJsonp([4],{\n\n/***/ 342:\n/***/ (function(module, exports) {\n\n\nmodule.exports = pathToRegexp;\n\nvar PATH_REGEXP = new RegExp(['(\\\\\\\\.)', '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n\nfunction parse(str) {\n    var tokens = [];\n    var key = 0;\n    var index = 0;\n    var path = '';\n    var defaultDelimiter = '/';\n    var res;\n\n    while ((res = PATH_REGEXP.exec(str)) != null) {\n        var m = res[0];\n        var escaped = res[1];\n        var offset = res.index;\n        path += str.slice(index, offset);\n        index = offset + m.length;\n\n        if (escaped) {\n            path += escaped[1];\n            continue;\n        }\n\n        var next = str[index];\n        var prefix = res[2];\n        var name = res[3];\n        var capture = res[4];\n        var group = res[5];\n        var modifier = res[6];\n        var asterisk = res[7];\n\n        if (path) {\n            tokens.push(path);\n            path = '';\n        }\n\n        var partial = prefix != null && next != null && next !== prefix;\n        var repeat = modifier === '+' || modifier === '*';\n        var optional = modifier === '?' || modifier === '*';\n        var delimiter = res[2] || defaultDelimiter;\n        var pattern = capture || group;\n\n        tokens.push({\n            name: name || key++,\n            prefix: prefix || '',\n            delimiter: delimiter,\n            optional: optional,\n            repeat: repeat,\n            partial: partial,\n            asterisk: !!asterisk,\n            pattern: pattern ? pattern.replace(/([=!:$\\/()])/g, '\\\\$1') : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n        });\n    }\n\n    if (index < str.length) {\n        path += str.substr(index);\n    }\n\n    if (path) {\n        tokens.push(path);\n    }\n\n    return tokens;\n}\n\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n\nfunction regexpToRegexp(path, keys) {\n    var groups = path.source.match(/\\((?!\\?)/g);\n\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: null,\n                delimiter: null,\n                optional: false,\n                repeat: false,\n                partial: false,\n                asterisk: false,\n                pattern: null\n            });\n        }\n    }\n\n    return path;\n}\n\nfunction stringToRegexp(path, keys) {\n    return tokensToRegExp(parse(path), keys);\n}\n\nfunction tokensToRegExp(tokens, keys) {\n    var route = '';\n\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n            route += escapeString(token);\n        } else {\n            var prefix = escapeString(token.prefix);\n            var capture = '(?:' + token.pattern + ')';\n\n            keys.push(token);\n\n            if (token.repeat) {\n                capture += '(?:' + prefix + capture + ')*';\n            }\n\n            if (token.optional) {\n                if (!token.partial) {\n                    capture = '(?:' + prefix + '(' + capture + '))?';\n                } else {\n                    capture = prefix + '(' + capture + ')?';\n                }\n            } else {\n                capture = prefix + '(' + capture + ')';\n            }\n\n            route += capture;\n        }\n    }\n\n    var delimiter = escapeString('/');\n    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?' + '$';\n\n    return new RegExp('^' + route, 'i');\n}\n\nfunction pathToRegexp(path, keys) {\n    if (path instanceof RegExp) {\n        return regexpToRegexp(path, keys);\n    }\n\n    return stringToRegexp(path, keys);\n}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// assets/js/4.7b697185a7780d1974f4.js","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n    // Match escaped characters that would otherwise appear in future matches.\n    // This allows the user to escape special characters that won't transform.\n    '(\\\\\\\\.)',\n    // Match Express-style parameters and un-named parameters with a prefix\n    // and optional suffixes. Matches appear as:\n    //\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n    // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n    '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @return {!Array}\n */\nfunction parse(str) {\n    var tokens = []\n    var key = 0\n    var index = 0\n    var path = ''\n    var defaultDelimiter = '/'\n    var res\n\n    while ((res = PATH_REGEXP.exec(str)) != null) {\n        var m = res[0]\n        var escaped = res[1]\n        var offset = res.index\n        path += str.slice(index, offset)\n        index = offset + m.length\n\n        // Ignore already escaped sequences.\n        if (escaped) {\n            path += escaped[1]\n            continue\n        }\n\n        var next = str[index]\n        var prefix = res[2]\n        var name = res[3]\n        var capture = res[4]\n        var group = res[5]\n        var modifier = res[6]\n        var asterisk = res[7]\n\n        // Push the current path onto the tokens.\n        if (path) {\n            tokens.push(path)\n            path = ''\n        }\n\n        var partial = prefix != null && next != null && next !== prefix\n        var repeat = modifier === '+' || modifier === '*'\n        var optional = modifier === '?' || modifier === '*'\n        var delimiter = res[2] || defaultDelimiter\n        var pattern = capture || group\n\n        tokens.push({\n            name: name || key++,\n            prefix: prefix || '',\n            delimiter: delimiter,\n            optional: optional,\n            repeat: repeat,\n            partial: partial,\n            asterisk: !!asterisk,\n            pattern: pattern ? pattern.replace(/([=!:$\\/()])/g, '\\\\$1') : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n        })\n    }\n\n    // Match any characters still remaining.\n    if (index < str.length) {\n        path += str.substr(index)\n    }\n\n    // If the path exists, push it onto the end.\n    if (path) {\n        tokens.push(path)\n    }\n\n    return tokens\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp(path, keys) {\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g)\n\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: null,\n                delimiter: null,\n                optional: false,\n                repeat: false,\n                partial: false,\n                asterisk: false,\n                pattern: null\n            })\n        }\n    }\n\n    return path;\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp(path, keys) {\n    return tokensToRegExp(parse(path), keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @return {!RegExp}\n */\nfunction tokensToRegExp(tokens, keys) {\n    var route = ''\n\n    // Iterate over the tokens and create our regexp string.\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n\n        if (typeof token === 'string') {\n            route += escapeString(token)\n        } else {\n            var prefix = escapeString(token.prefix)\n            var capture = '(?:' + token.pattern + ')'\n\n            keys.push(token)\n\n            if (token.repeat) {\n                capture += '(?:' + prefix + capture + ')*'\n            }\n\n            if (token.optional) {\n                if (!token.partial) {\n                    capture = '(?:' + prefix + '(' + capture + '))?'\n                } else {\n                    capture = prefix + '(' + capture + ')?'\n                }\n            } else {\n                capture = prefix + '(' + capture + ')'\n            }\n\n            route += capture\n        }\n    }\n\n    var delimiter = escapeString('/')\n    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n    // In non-strict mode we allow a slash at the end of match. If the path to\n    // match already ends with a slash, we remove it for consistency. The slash\n    // is valid at the end of a path match, not in the middle. This is important\n    // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?' + '$';\n\n    return new RegExp('^' + route, 'i');\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @return {!RegExp}\n */\nfunction pathToRegexp(path, keys) {\n    if (path instanceof RegExp) {\n        return regexpToRegexp(path, /** @type {!Array} */ (keys))\n    }\n\n    return stringToRegexp( /** @type {string} */ (path), /** @type {!Array} */ (keys))\n}\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/utils/path-to-regexp.js"],"sourceRoot":""}